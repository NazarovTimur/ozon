// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package notes_repository

import (
	"context"
)

const insertNote = `-- name: InsertNote :one
insert into note(title, content, author)
VALUES ($1, $2, $3)
returning id
`

type InsertNoteParams struct {
	Title   string
	Content *string
	Author  string
}

func (q *Queries) InsertNote(ctx context.Context, arg *InsertNoteParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertNote, arg.Title, arg.Content, arg.Author)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertNoteTag = `-- name: InsertNoteTag :exec
insert into note_tag(note_id, tag_id)
select $1, id
from tag
where value = $2
`

type InsertNoteTagParams struct {
	NoteID int32
	Tag    string
}

func (q *Queries) InsertNoteTag(ctx context.Context, arg *InsertNoteTagParams) error {
	_, err := q.db.Exec(ctx, insertNoteTag, arg.NoteID, arg.Tag)
	return err
}

const insertTag = `-- name: InsertTag :exec
insert into tag (value)
values ($1)
on conflict (value) do nothing
`

func (q *Queries) InsertTag(ctx context.Context, note string) error {
	_, err := q.db.Exec(ctx, insertTag, note)
	return err
}

const listNotes = `-- name: ListNotes :many
select id, title, content, tags.value tags
from note n
         left join lateral (select array_agg(t.value)::text[] value
                            from tag t
                                     inner join note_tag nt on t.id = nt.tag_id
                            where nt.note_id = n.id
    ) tags on true
where n.author = $1
`

type ListNotesRow struct {
	ID      int32
	Title   string
	Content *string
	Tags    []string
}

func (q *Queries) ListNotes(ctx context.Context, author string) ([]*ListNotesRow, error) {
	rows, err := q.db.Query(ctx, listNotes, author)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListNotesRow
	for rows.Next() {
		var i ListNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
